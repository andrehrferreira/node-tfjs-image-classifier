{"version":3,"sources":["../../src/models/default.js"],"names":["tf","process","env","gpu","require","DefaultOptions","inputWidth","inputHeight","inputChannels","learningRate","optimizer","DefaultModel","options","outputSize","model","sequential","layers","flatten","inputShape","dense","units","activation","kernelInitializer","useBias","optimzer","Optimizer","compile","getOptimzer","loss","metrics"],"mappings":";;;;;;;AAAA;;;;;;;;;;AACA,IAAMA,EAAE,GAAIC,OAAO,CAACC,GAAR,CAAYC,GAAZ,KAAoB,IAArB,GAA6BC,OAAO,CAAC,2BAAD,CAApC,GAAoEA,OAAO,CAAC,uBAAD,CAAtF;AAEA,IAAMC,cAAc,GAAG;AACnBC,EAAAA,UAAU,EAAE,GADO;AAEnBC,EAAAA,WAAW,EAAE,GAFM;AAGnBC,EAAAA,aAAa,EAAE,CAHI;AAInBC,EAAAA,YAAY,EAAE,MAJK;AAKnBC,EAAAA,SAAS,EAAE;AALQ,CAAvB;;IAQMC,Y;AACF,wBAAYC,OAAZ,EAAoB;AAAA;;AAChB,SAAKA,OAAL,GAAeA,OAAO,IAAIP,cAA1B;AACA,SAAKC,UAAL,GAAkBM,OAAO,CAACN,UAAR,IAAsBD,cAAc,CAACC,UAAvD;AACA,SAAKC,WAAL,GAAmBK,OAAO,CAACL,WAAR,IAAuBF,cAAc,CAACE,WAAzD;AACA,SAAKC,aAAL,GAAqBI,OAAO,CAACJ,aAAR,IAAyBH,cAAc,CAACG,aAA7D;AACA,SAAKC,YAAL,GAAoBG,OAAO,CAACH,YAAR,IAAwBJ,cAAc,CAACI,YAA3D;AACH;;;;6BAEQI,U,EAAW;AAEhB;AACA,WAAKC,KAAL,GAAad,EAAE,CAACe,UAAH,CAAc;AACvBC,QAAAA,MAAM,EAAE,CACJhB,EAAE,CAACgB,MAAH,CAAUC,OAAV,CAAkB;AACdC,UAAAA,UAAU,EAAE,CAAC,KAAKX,WAAN,EAAmB,KAAKD,UAAxB,EAAoC,KAAKE,aAAzC;AADE,SAAlB,CADI,EAIJR,EAAE,CAACgB,MAAH,CAAUG,KAAV,CAAgB;AACZC,UAAAA,KAAK,EAAE,EADK;AAEZC,UAAAA,UAAU,EAAE,MAFA;AAGZC,UAAAA,iBAAiB,EAAE,iBAHP;AAIZC,UAAAA,OAAO,EAAE;AAJG,SAAhB,CAJI,EAUJvB,EAAE,CAACgB,MAAH,CAAUG,KAAV,CAAgB;AACZC,UAAAA,KAAK,EAAEP,UADK;AAEZS,UAAAA,iBAAiB,EAAE,iBAFP;AAGZD,UAAAA,UAAU,EAAE,SAHA;AAIZE,UAAAA,OAAO,EAAE;AAJG,SAAhB,CAVI;AADe,OAAd,CAAb,CAHgB,CAuBhB;;AACA,UAAIC,QAAQ,GAAG,IAAIC,qBAAJ,CAAc,KAAKb,OAAnB,CAAf;AAEA,WAAKE,KAAL,CAAWY,OAAX,CAAmB;AACfhB,QAAAA,SAAS,EAAEc,QAAQ,CAACG,WAAT,EADI;AAEfC,QAAAA,IAAI,EAAE,yBAFS;AAGfC,QAAAA,OAAO,EAAE,CAAC,UAAD;AAHM,OAAnB;AAMA,aAAO,KAAKf,KAAZ;AACH;;;;;;eAGUH,Y","sourcesContent":["import Optimizer from \"../Optimizer\";\r\nconst tf = (process.env.gpu === true) ? require(\"@tensorflow/tfjs-node-gpu\") : require(\"@tensorflow/tfjs-node\");\r\n\r\nconst DefaultOptions = {\r\n    inputWidth: 224,\r\n    inputHeight: 224,\r\n    inputChannels: 3,\r\n    learningRate: 0.0001,\r\n    optimizer: \"adam\"\r\n};\r\n\r\nclass DefaultModel {\r\n    constructor(options){\r\n        this.options = options || DefaultOptions;\r\n        this.inputWidth = options.inputWidth || DefaultOptions.inputWidth;\r\n        this.inputHeight = options.inputHeight || DefaultOptions.inputHeight;\r\n        this.inputChannels = options.inputChannels || DefaultOptions.inputChannels;\r\n        this.learningRate = options.learningRate || DefaultOptions.learningRate;\r\n    }\r\n\r\n    generate(outputSize){       \r\n\r\n        //Input\r\n        this.model = tf.sequential({\r\n            layers: [\r\n                tf.layers.flatten({ \r\n                    inputShape: [this.inputHeight, this.inputWidth, this.inputChannels] \r\n                }),\r\n                tf.layers.dense({ \r\n                    units: 64, \r\n                    activation: \"relu\", \r\n                    kernelInitializer: \"varianceScaling\", \r\n                    useBias: true \r\n                }),\r\n                tf.layers.dense({ \r\n                    units: outputSize, \r\n                    kernelInitializer: \"varianceScaling\",\r\n                    activation: \"softmax\",\r\n                    useBias: false,\r\n                })\r\n            ]\r\n        });\r\n \r\n        //Output\r\n        let optimzer = new Optimizer(this.options);\r\n        \r\n        this.model.compile({\r\n            optimizer: optimzer.getOptimzer(),\r\n            loss: \"categoricalCrossentropy\",\r\n            metrics: [\"accuracy\"]\r\n        });\r\n    \r\n        return this.model;\r\n    }\r\n}\r\n\r\nexport default DefaultModel;"],"file":"default.js"}