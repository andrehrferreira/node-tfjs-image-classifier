{"version":3,"sources":["../src/Data.js"],"names":["tf","process","env","gpu","require","DefaultOptions","inputWidth","inputHeight","inputChannels","learningRate","optimizer","TFJSData","options","labels","tensor","info","tidy","slice","height","width","pixelData","filename","outShape","tensor4d","noAlpha","__stripAlphaChannel","normalized","toFloat","div","scalar","sub","err","console","log","resize","raw","toBuffer","resolveWithObject","data","__imageToTensor","buffer","Buffer","from","dirname","onlyDirectories","diretories","map","dir","path","basename","Promise","all","onlyFiles","images","sizes","arr","length","filenameData","filenameLabels","filesBin","i","fs","readFileSync","bufferArr","Float32Array","embeddingsShape","embeddingsFlatSize","util","sizeFromShape","index","pArr","fse","readJson","then","obj","Labels","model","embeddings","key","embeddingsOffset","keyImages","__fileToBuffer","set","dataBuffer","writeFileSync","writeJson","totalImages","item","reduce","accumulator","currentValue","embeddingsShapeTotal","totalDataSize","maxSize","batchCount","Math","ceil","maxBatchSize","predictionsPerBatch","floor","batchSize","batchIndex","Int32Array","labelsOffset","time","__bufferToTensor","__fileToTensor","tmpBuffer","prediction","predict","dispose","squeeze","exit","timeLog","label","count","imagesTensor","stack","forEach","oneHot","tensor1d"],"mappings":"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","sourcesContent":["/**\r\n * \r\n * @see https://github.com/longlost/node-tfjs-retrain/blob/master/data.js\r\n */\r\n\r\nimport path from \"path\";\r\nimport fg from \"fast-glob\";\r\nimport fse from \"fs-extra\";\r\nimport fs from \"fs\";\r\nimport sharp from \"sharp\";\r\nimport tobuffer from \"typedarray-to-buffer\";\r\n\r\nconst tf = (process.env.gpu === true) ? require(\"@tensorflow/tfjs-node-gpu\") : require(\"@tensorflow/tfjs-node\");\r\n\r\nconst DefaultOptions = {\r\n    inputWidth: 7,\r\n    inputHeight: 7,\r\n    inputChannels: 1024,\r\n    learningRate: 0.0001,\r\n    optimizer: \"adam\"\r\n};\r\n\r\nclass TFJSData {\r\n    constructor(options){\r\n        this.options = options || DefaultOptions;\r\n        this.inputWidth = options.inputWidth || DefaultOptions.inputWidth;\r\n        this.inputHeight = options.inputHeight || DefaultOptions.inputHeight;\r\n        this.inputChannels = options.inputChannels || DefaultOptions.inputChannels;\r\n        this.labels = null;\r\n    }\r\n\r\n    __stripAlphaChannel(tensor, info){\r\n        return tf.tidy(() => tensor.slice(\r\n            [0, 0, 0 ,0], \r\n            [1, info.height, info.width, 3]\r\n        ));\r\n    }\r\n\r\n    __imageToTensor(pixelData, filename){\r\n        let outShape = [1, this.inputHeight, this.inputWidth, this.inputChannels];        \r\n\r\n        try{\r\n            return tf.tidy(() => {\r\n                // rgba -> rgb / the rest of the pipeline throws if \r\n                // alpha channel is present so pull it out and \r\n                // keep a shape [1, 224, 224, 3] tensor\r\n                const outShape = [1, this.inputHeight, this.inputWidth, this.inputChannels];\r\n                const tensor   = tf.tensor4d(pixelData, outShape, \"int32\"); \r\n                const noAlpha  = this.__stripAlphaChannel(tensor, {\r\n                    height: this.inputHeight,\r\n                    width: this.inputWidth\r\n                });\r\n\r\n                // Normalize the rgb data from [0, 255] to [-1, 1].\r\n                const normalized = noAlpha.  \r\n                    toFloat().\r\n                    div(tf.scalar(127)).\r\n                    sub(tf.scalar(1));\r\n            \r\n                return normalized;\r\n            });\r\n\r\n            /*return tf.tidy(() =>\r\n                tf.tensor4d(pixelData, outShape, \"int32\")\r\n                    //.resizeBilinear([this.inputWidth, this.inputHeight])\r\n                    .toFloat()\r\n                    .div(tf.scalar(127))\r\n                    .sub(tf.scalar(1))\r\n            );*/\r\n        }\r\n        catch(err){\r\n            console.log(filename, pixelData);\r\n            throw err;\r\n        }\r\n    }\r\n\r\n    async __fileToTensor(filename){\r\n        let { data } = await sharp(filename)\r\n            .resize({ width: this.inputWidth, height: this.inputHeight })\r\n            .raw()\r\n            .toBuffer({ resolveWithObject: true });\r\n\r\n        return this.__imageToTensor(data, filename);\r\n    }\r\n\r\n    async __bufferToTensor(buffer){\r\n        return this.__imageToTensor(Buffer.from(buffer));\r\n    }\r\n\r\n    async __fileToBuffer(filename){\r\n        const { data } = await sharp(filename)\r\n            .resize({ width: this.inputWidth, height: this.inputHeight })\r\n            .raw()\r\n            .toBuffer({ resolveWithObject: true });\r\n\r\n        return data;\r\n    }\r\n\r\n    async loadFromDirectory(dirname){\r\n        let diretories = await fg(`${dirname}/*`, { onlyDirectories: true });\r\n        this.labels = diretories.map((dir) => { return path.basename(dir); });\r\n        this.images = await Promise.all(diretories.map(async (dir) => { return await fg(`${dir}/*`, { onlyFiles: true }); }));\r\n        this.sizes = this.images.map((arr) => arr.length);\r\n    }\r\n\r\n    async loadFromData(filenameData, filenameLabels){\r\n        let filesBin = await fg(`${filenameData}.*`, { onlyFiles: true });\r\n        this.images = [];\r\n        \r\n        for(let i = 0; i < filesBin.length; i++){\r\n            console.log(`Loading ${filenameData}.${i}...`);\r\n\r\n            let buffer = fs.readFileSync(`${filenameData}.${i}`);\r\n            let bufferArr = new Float32Array(buffer);\r\n\r\n            if(!this.images[i])\r\n                this.images[i] = [];\r\n\r\n            let embeddingsShape = [this.inputHeight, this.inputWidth, this.inputChannels];\r\n            let embeddingsFlatSize = tf.util.sizeFromShape(embeddingsShape);\r\n            let index = 0;\r\n\r\n            for (let pArr = 0; pArr < bufferArr.length; pArr += embeddingsFlatSize){\r\n                this.images[i][index] = bufferArr.slice(pArr, pArr + embeddingsFlatSize);\r\n                index++;\r\n            }\r\n        }\r\n\r\n        this.sizes = this.images.map((arr) => arr.length);\r\n        \r\n        this.labels = await fse\r\n            .readJson(filenameLabels)\r\n            .then(obj => obj.Labels);\r\n    }\r\n\r\n    async saveTrainingData(model, filenameData, filenameLabels){\r\n        let embeddings = [];\r\n    \r\n        for (let key in this.labels) {\r\n            let embeddingsOffset = 0;\r\n            let embeddingsShape = [this.images[key].length, this.inputHeight, this.inputWidth, this.inputChannels];\r\n            let embeddingsFlatSize = tf.util.sizeFromShape([this.inputHeight, this.inputWidth, this.inputChannels]);\r\n            embeddings[key] = new Float32Array(tf.util.sizeFromShape(embeddingsShape));\r\n\r\n            for (let keyImages in this.images[key]) {\r\n                embeddings[key].set(await this.__fileToBuffer(this.images[key][keyImages]), embeddingsOffset);\r\n                embeddingsOffset += embeddingsFlatSize;\r\n            }\r\n\r\n            let dataBuffer = Buffer.from(embeddings[key]);\r\n            fs.writeFileSync(`${filenameData}.${key}`, dataBuffer);\r\n            console.log(`Saving ${filenameData}.${key}...`);\r\n        }\r\n\r\n        await fse.writeJson(filenameLabels, {\r\n            Labels: this.labels\r\n        });\r\n    }\r\n\r\n    async toTrain(model) {\r\n        let totalImages = this.images.map((item) => item.length).reduce((accumulator, currentValue) => accumulator + currentValue);\r\n        let embeddingsShape = [this.inputHeight, this.inputWidth, this.inputChannels];\r\n        let embeddingsShapeTotal = [totalImages, this.inputHeight, this.inputWidth, this.inputChannels];\r\n        let embeddingsFlatSize = tf.util.sizeFromShape(embeddingsShape);\r\n\r\n        const totalDataSize = tf.util.sizeFromShape(embeddingsShapeTotal);\r\n        const maxSize = (2 ** 30) - 1;\r\n\r\n        const batchCount = totalDataSize > maxSize ?  Math.ceil(totalDataSize / maxSize) : 1;\r\n        const maxBatchSize = totalDataSize / batchCount;\r\n        const predictionsPerBatch = Math.floor(maxBatchSize / embeddingsFlatSize);\r\n\r\n        const batchSize = predictionsPerBatch * embeddingsFlatSize;\r\n        let batchIndex = 0;\r\n                \r\n        //let embeddings = new Float32Array(tf.util.sizeFromShape(embeddingsShape));\r\n        //const embeddings = new Float32Array(batchSize);\r\n        const embeddings = [];\r\n        let embeddingsOffset = 0;\r\n\r\n        const labels = new Int32Array(totalImages);        \r\n        let labelsOffset = 0;\r\n\r\n        console.time(\"Loading Training Data\");\r\n\r\n        for (let key in this.labels) {            \r\n            for (let keyImages in this.images[key]) {\r\n                let tmpBuffer = (typeof this.images[key][keyImages] == \"object\") ? await this.__bufferToTensor(this.images[key][keyImages]) : await this.__fileToTensor(this.images[key][keyImages]);\r\n                \r\n                let prediction = model.predict(tmpBuffer);\r\n                tmpBuffer.dispose();\r\n                    \r\n                //embeddings.push(prediction.squeeze());\r\n                //labels.set([key], labelsOffset);\r\n\r\n                console.log(prediction.squeeze());\r\n                process.exit(1);\r\n\r\n                embeddingsOffset += embeddingsFlatSize;\r\n                labelsOffset++;  \r\n            }\r\n\r\n            console.timeLog(\"Loading Training Data\", {\r\n                label: this.labels[key],\r\n                count: this.images[key].length\r\n            });\r\n        }\r\n\r\n        try{\r\n            const imagesTensor = tf.stack(embeddings);\r\n            embeddings.forEach(tensor => { tensor.dispose(); });\r\n            console.log(imagesTensor);\r\n            \r\n            console.log(tf.tensor4d(imagesTensor, embeddingsShapeTotal));\r\n            process.exit(1);\r\n\r\n            return {\r\n                images: imagesTensor, //tf.tensor4d(embeddings, embeddingsShape),\r\n                labels: tf.oneHot(tf.tensor1d(labels, \"int32\"), this.labels.length)\r\n            };\r\n        }\r\n        catch(err){\r\n            console.log(\"aki\", err);\r\n        }\r\n    }\r\n}\r\n\r\nexport default TFJSData;"],"file":"Data.js"}